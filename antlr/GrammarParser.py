# Generated from Grammar.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\37")
        buf.write("\u0085\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\3\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\7\3%\n\3\f\3\16")
        buf.write("\3(\13\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4\62\n\4\3")
        buf.write("\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\7\3\7\3\7")
        buf.write("\3\7\3\7\5\7D\n\7\3\b\3\b\3\b\3\b\3\b\3\b\5\bL\n\b\3\t")
        buf.write("\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\n\3\n\3\n\3\n\3")
        buf.write("\n\3\n\3\n\5\n_\n\n\3\13\3\13\3\13\3\13\3\13\5\13f\n\13")
        buf.write("\3\f\6\fi\n\f\r\f\16\fj\3\f\3\f\5\fo\n\f\3\r\3\r\3\r\3")
        buf.write("\r\3\r\3\r\3\r\3\r\3\r\3\r\5\r{\n\r\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\5\16\u0083\n\16\3\16\2\2\17\2\4\6\b\n\f\16")
        buf.write("\20\22\24\26\30\32\2\2\2\u0088\2\34\3\2\2\2\4\37\3\2\2")
        buf.write("\2\6\61\3\2\2\2\b\63\3\2\2\2\n\67\3\2\2\2\fC\3\2\2\2\16")
        buf.write("K\3\2\2\2\20M\3\2\2\2\22^\3\2\2\2\24e\3\2\2\2\26n\3\2")
        buf.write("\2\2\30z\3\2\2\2\32\u0082\3\2\2\2\34\35\5\4\3\2\35\36")
        buf.write("\7\2\2\3\36\3\3\2\2\2\37 \5\6\4\2 &\7\6\2\2!\"\5\6\4\2")
        buf.write("\"#\7\6\2\2#%\3\2\2\2$!\3\2\2\2%(\3\2\2\2&$\3\2\2\2&\'")
        buf.write("\3\2\2\2\'\5\3\2\2\2(&\3\2\2\2)*\7\31\2\2*+\7\32\2\2+")
        buf.write("\62\7\36\2\2,-\7\26\2\2-.\7\27\2\2.\62\7\30\2\2/\62\5")
        buf.write("\n\6\2\60\62\5\b\5\2\61)\3\2\2\2\61,\3\2\2\2\61/\3\2\2")
        buf.write("\2\61\60\3\2\2\2\62\7\3\2\2\2\63\64\7\35\2\2\64\65\7\16")
        buf.write("\2\2\65\66\5\24\13\2\66\t\3\2\2\2\678\7\25\2\289\5\f\7")
        buf.write("\29:\7\23\2\2:;\7\36\2\2;<\7\24\2\2<=\5\20\t\2=\13\3\2")
        buf.write("\2\2>D\5\16\b\2?@\7\21\2\2@D\5\16\b\2AB\7\22\2\2BD\5\16")
        buf.write("\b\2C>\3\2\2\2C?\3\2\2\2CA\3\2\2\2D\r\3\2\2\2EF\7\3\2")
        buf.write("\2FG\7\33\2\2GH\7\5\2\2HI\7\33\2\2IL\7\4\2\2JL\7\33\2")
        buf.write("\2KE\3\2\2\2KJ\3\2\2\2L\17\3\2\2\2MN\7\3\2\2NO\5\22\n")
        buf.write("\2OP\7\4\2\2PQ\7\f\2\2QR\5\24\13\2RS\7\r\2\2ST\7\3\2\2")
        buf.write("TU\5\22\n\2UV\7\4\2\2V\21\3\2\2\2W_\7\33\2\2X_\7\17\2")
        buf.write("\2YZ\7\33\2\2Z[\7\b\2\2[\\\7\20\2\2\\]\7\16\2\2]_\7\34")
        buf.write("\2\2^W\3\2\2\2^X\3\2\2\2^Y\3\2\2\2_\23\3\2\2\2`f\5\26")
        buf.write("\f\2ab\5\26\f\2bc\7\7\2\2cd\5\24\13\2df\3\2\2\2e`\3\2")
        buf.write("\2\2ea\3\2\2\2f\25\3\2\2\2gi\5\30\r\2hg\3\2\2\2ij\3\2")
        buf.write("\2\2jh\3\2\2\2jk\3\2\2\2ko\3\2\2\2lm\7\3\2\2mo\7\4\2\2")
        buf.write("nh\3\2\2\2nl\3\2\2\2o\27\3\2\2\2p{\5\32\16\2qr\5\32\16")
        buf.write("\2rs\7\t\2\2s{\3\2\2\2tu\5\32\16\2uv\7\n\2\2v{\3\2\2\2")
        buf.write("wx\5\32\16\2xy\7\13\2\2y{\3\2\2\2zp\3\2\2\2zq\3\2\2\2")
        buf.write("zt\3\2\2\2zw\3\2\2\2{\31\3\2\2\2|\u0083\7\33\2\2}\u0083")
        buf.write("\7\35\2\2~\177\7\3\2\2\177\u0080\5\24\13\2\u0080\u0081")
        buf.write("\7\4\2\2\u0081\u0083\3\2\2\2\u0082|\3\2\2\2\u0082}\3\2")
        buf.write("\2\2\u0082~\3\2\2\2\u0083\33\3\2\2\2\f&\61CK^ejnz\u0082")
        return buf.getvalue()


class GrammarParser ( Parser ):

    grammarFileName = "Grammar.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'('", "')'", "','", "';'", "'|'", "'.'", 
                     "'*'", "'+'", "'?'", "'-'", "'->'", "'='", "'_'", "'ID'", 
                     "'count'", "'exists'", "'from'", "'where'", "'select'", 
                     "'list'", "'all'", "'graphs'", "'connect'", "'to'" ]

    symbolicNames = [ "<INVALID>", "LBR", "RBR", "COMMA", "SEMI", "MID", 
                      "DOT", "OP_STAR", "OP_PLUS", "OP_Q", "OP_MINUS", "OP_ARROW", 
                      "OP_EQ", "UNDERSCORE", "KW_ID", "KW_COUNT", "KW_EXISTS", 
                      "KW_FROM", "KW_WHERE", "KW_SELECT", "KW_LIST", "KW_ALL", 
                      "KW_GRAPHS", "KW_CONNECT", "KW_TO", "IDENT", "INT", 
                      "NT_NAME", "STRING", "WS" ]

    RULE_complete_script = 0
    RULE_script = 1
    RULE_stmt = 2
    RULE_named_pattern_stmt = 3
    RULE_select_stmt = 4
    RULE_obj_expr = 5
    RULE_vs_info = 6
    RULE_where_expr = 7
    RULE_v_expr = 8
    RULE_pattern = 9
    RULE_alt_elem = 10
    RULE_seq_elem = 11
    RULE_prim_pattern = 12

    ruleNames =  [ "complete_script", "script", "stmt", "named_pattern_stmt", 
                   "select_stmt", "obj_expr", "vs_info", "where_expr", "v_expr", 
                   "pattern", "alt_elem", "seq_elem", "prim_pattern" ]

    EOF = Token.EOF
    LBR=1
    RBR=2
    COMMA=3
    SEMI=4
    MID=5
    DOT=6
    OP_STAR=7
    OP_PLUS=8
    OP_Q=9
    OP_MINUS=10
    OP_ARROW=11
    OP_EQ=12
    UNDERSCORE=13
    KW_ID=14
    KW_COUNT=15
    KW_EXISTS=16
    KW_FROM=17
    KW_WHERE=18
    KW_SELECT=19
    KW_LIST=20
    KW_ALL=21
    KW_GRAPHS=22
    KW_CONNECT=23
    KW_TO=24
    IDENT=25
    INT=26
    NT_NAME=27
    STRING=28
    WS=29

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class Complete_scriptContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def script(self):
            return self.getTypedRuleContext(GrammarParser.ScriptContext,0)


        def EOF(self):
            return self.getToken(GrammarParser.EOF, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_complete_script

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComplete_script" ):
                listener.enterComplete_script(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComplete_script" ):
                listener.exitComplete_script(self)




    def complete_script(self):

        localctx = GrammarParser.Complete_scriptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_complete_script)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 26
            self.script()
            self.state = 27
            self.match(GrammarParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ScriptContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.StmtContext)
            else:
                return self.getTypedRuleContext(GrammarParser.StmtContext,i)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.SEMI)
            else:
                return self.getToken(GrammarParser.SEMI, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_script

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScript" ):
                listener.enterScript(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScript" ):
                listener.exitScript(self)




    def script(self):

        localctx = GrammarParser.ScriptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_script)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 29
            self.stmt()
            self.state = 30
            self.match(GrammarParser.SEMI)
            self.state = 36
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GrammarParser.KW_SELECT) | (1 << GrammarParser.KW_LIST) | (1 << GrammarParser.KW_CONNECT) | (1 << GrammarParser.NT_NAME))) != 0):
                self.state = 31
                self.stmt()
                self.state = 32
                self.match(GrammarParser.SEMI)
                self.state = 38
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_CONNECT(self):
            return self.getToken(GrammarParser.KW_CONNECT, 0)

        def KW_TO(self):
            return self.getToken(GrammarParser.KW_TO, 0)

        def STRING(self):
            return self.getToken(GrammarParser.STRING, 0)

        def KW_LIST(self):
            return self.getToken(GrammarParser.KW_LIST, 0)

        def KW_ALL(self):
            return self.getToken(GrammarParser.KW_ALL, 0)

        def KW_GRAPHS(self):
            return self.getToken(GrammarParser.KW_GRAPHS, 0)

        def select_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Select_stmtContext,0)


        def named_pattern_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Named_pattern_stmtContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmt" ):
                listener.enterStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmt" ):
                listener.exitStmt(self)




    def stmt(self):

        localctx = GrammarParser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_stmt)
        try:
            self.state = 47
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.KW_CONNECT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 39
                self.match(GrammarParser.KW_CONNECT)
                self.state = 40
                self.match(GrammarParser.KW_TO)
                self.state = 41
                self.match(GrammarParser.STRING)
                pass
            elif token in [GrammarParser.KW_LIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 42
                self.match(GrammarParser.KW_LIST)
                self.state = 43
                self.match(GrammarParser.KW_ALL)
                self.state = 44
                self.match(GrammarParser.KW_GRAPHS)
                pass
            elif token in [GrammarParser.KW_SELECT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 45
                self.select_stmt()
                pass
            elif token in [GrammarParser.NT_NAME]:
                self.enterOuterAlt(localctx, 4)
                self.state = 46
                self.named_pattern_stmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Named_pattern_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NT_NAME(self):
            return self.getToken(GrammarParser.NT_NAME, 0)

        def OP_EQ(self):
            return self.getToken(GrammarParser.OP_EQ, 0)

        def pattern(self):
            return self.getTypedRuleContext(GrammarParser.PatternContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_named_pattern_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamed_pattern_stmt" ):
                listener.enterNamed_pattern_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamed_pattern_stmt" ):
                listener.exitNamed_pattern_stmt(self)




    def named_pattern_stmt(self):

        localctx = GrammarParser.Named_pattern_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_named_pattern_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 49
            self.match(GrammarParser.NT_NAME)
            self.state = 50
            self.match(GrammarParser.OP_EQ)
            self.state = 51
            self.pattern()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_stmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_SELECT(self):
            return self.getToken(GrammarParser.KW_SELECT, 0)

        def obj_expr(self):
            return self.getTypedRuleContext(GrammarParser.Obj_exprContext,0)


        def KW_FROM(self):
            return self.getToken(GrammarParser.KW_FROM, 0)

        def STRING(self):
            return self.getToken(GrammarParser.STRING, 0)

        def KW_WHERE(self):
            return self.getToken(GrammarParser.KW_WHERE, 0)

        def where_expr(self):
            return self.getTypedRuleContext(GrammarParser.Where_exprContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_select_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_stmt" ):
                listener.enterSelect_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_stmt" ):
                listener.exitSelect_stmt(self)




    def select_stmt(self):

        localctx = GrammarParser.Select_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_select_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self.match(GrammarParser.KW_SELECT)
            self.state = 54
            self.obj_expr()
            self.state = 55
            self.match(GrammarParser.KW_FROM)
            self.state = 56
            self.match(GrammarParser.STRING)
            self.state = 57
            self.match(GrammarParser.KW_WHERE)
            self.state = 58
            self.where_expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Obj_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vs_info(self):
            return self.getTypedRuleContext(GrammarParser.Vs_infoContext,0)


        def KW_COUNT(self):
            return self.getToken(GrammarParser.KW_COUNT, 0)

        def KW_EXISTS(self):
            return self.getToken(GrammarParser.KW_EXISTS, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_obj_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObj_expr" ):
                listener.enterObj_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObj_expr" ):
                listener.exitObj_expr(self)




    def obj_expr(self):

        localctx = GrammarParser.Obj_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_obj_expr)
        try:
            self.state = 65
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.LBR, GrammarParser.IDENT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 60
                self.vs_info()
                pass
            elif token in [GrammarParser.KW_COUNT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 61
                self.match(GrammarParser.KW_COUNT)
                self.state = 62
                self.vs_info()
                pass
            elif token in [GrammarParser.KW_EXISTS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 63
                self.match(GrammarParser.KW_EXISTS)
                self.state = 64
                self.vs_info()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vs_infoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBR(self):
            return self.getToken(GrammarParser.LBR, 0)

        def IDENT(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.IDENT)
            else:
                return self.getToken(GrammarParser.IDENT, i)

        def COMMA(self):
            return self.getToken(GrammarParser.COMMA, 0)

        def RBR(self):
            return self.getToken(GrammarParser.RBR, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_vs_info

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVs_info" ):
                listener.enterVs_info(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVs_info" ):
                listener.exitVs_info(self)




    def vs_info(self):

        localctx = GrammarParser.Vs_infoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_vs_info)
        try:
            self.state = 73
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.LBR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 67
                self.match(GrammarParser.LBR)
                self.state = 68
                self.match(GrammarParser.IDENT)
                self.state = 69
                self.match(GrammarParser.COMMA)
                self.state = 70
                self.match(GrammarParser.IDENT)
                self.state = 71
                self.match(GrammarParser.RBR)
                pass
            elif token in [GrammarParser.IDENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 72
                self.match(GrammarParser.IDENT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Where_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.LBR)
            else:
                return self.getToken(GrammarParser.LBR, i)

        def v_expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.V_exprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.V_exprContext,i)


        def RBR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.RBR)
            else:
                return self.getToken(GrammarParser.RBR, i)

        def OP_MINUS(self):
            return self.getToken(GrammarParser.OP_MINUS, 0)

        def pattern(self):
            return self.getTypedRuleContext(GrammarParser.PatternContext,0)


        def OP_ARROW(self):
            return self.getToken(GrammarParser.OP_ARROW, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_where_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhere_expr" ):
                listener.enterWhere_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhere_expr" ):
                listener.exitWhere_expr(self)




    def where_expr(self):

        localctx = GrammarParser.Where_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_where_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 75
            self.match(GrammarParser.LBR)
            self.state = 76
            self.v_expr()
            self.state = 77
            self.match(GrammarParser.RBR)
            self.state = 78
            self.match(GrammarParser.OP_MINUS)
            self.state = 79
            self.pattern()
            self.state = 80
            self.match(GrammarParser.OP_ARROW)
            self.state = 81
            self.match(GrammarParser.LBR)
            self.state = 82
            self.v_expr()
            self.state = 83
            self.match(GrammarParser.RBR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class V_exprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(GrammarParser.IDENT, 0)

        def UNDERSCORE(self):
            return self.getToken(GrammarParser.UNDERSCORE, 0)

        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def KW_ID(self):
            return self.getToken(GrammarParser.KW_ID, 0)

        def OP_EQ(self):
            return self.getToken(GrammarParser.OP_EQ, 0)

        def INT(self):
            return self.getToken(GrammarParser.INT, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_v_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterV_expr" ):
                listener.enterV_expr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitV_expr" ):
                listener.exitV_expr(self)




    def v_expr(self):

        localctx = GrammarParser.V_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_v_expr)
        try:
            self.state = 92
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 85
                self.match(GrammarParser.IDENT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 86
                self.match(GrammarParser.UNDERSCORE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 87
                self.match(GrammarParser.IDENT)
                self.state = 88
                self.match(GrammarParser.DOT)
                self.state = 89
                self.match(GrammarParser.KW_ID)
                self.state = 90
                self.match(GrammarParser.OP_EQ)
                self.state = 91
                self.match(GrammarParser.INT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alt_elem(self):
            return self.getTypedRuleContext(GrammarParser.Alt_elemContext,0)


        def MID(self):
            return self.getToken(GrammarParser.MID, 0)

        def pattern(self):
            return self.getTypedRuleContext(GrammarParser.PatternContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)




    def pattern(self):

        localctx = GrammarParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_pattern)
        try:
            self.state = 99
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 94
                self.alt_elem()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 95
                self.alt_elem()
                self.state = 96
                self.match(GrammarParser.MID)
                self.state = 97
                self.pattern()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Alt_elemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def seq_elem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Seq_elemContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Seq_elemContext,i)


        def LBR(self):
            return self.getToken(GrammarParser.LBR, 0)

        def RBR(self):
            return self.getToken(GrammarParser.RBR, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_alt_elem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlt_elem" ):
                listener.enterAlt_elem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlt_elem" ):
                listener.exitAlt_elem(self)




    def alt_elem(self):

        localctx = GrammarParser.Alt_elemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_alt_elem)
        self._la = 0 # Token type
        try:
            self.state = 108
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 102 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 101
                    self.seq_elem()
                    self.state = 104 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GrammarParser.LBR) | (1 << GrammarParser.IDENT) | (1 << GrammarParser.NT_NAME))) != 0)):
                        break

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 106
                self.match(GrammarParser.LBR)
                self.state = 107
                self.match(GrammarParser.RBR)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Seq_elemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def prim_pattern(self):
            return self.getTypedRuleContext(GrammarParser.Prim_patternContext,0)


        def OP_STAR(self):
            return self.getToken(GrammarParser.OP_STAR, 0)

        def OP_PLUS(self):
            return self.getToken(GrammarParser.OP_PLUS, 0)

        def OP_Q(self):
            return self.getToken(GrammarParser.OP_Q, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_seq_elem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSeq_elem" ):
                listener.enterSeq_elem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSeq_elem" ):
                listener.exitSeq_elem(self)




    def seq_elem(self):

        localctx = GrammarParser.Seq_elemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_seq_elem)
        try:
            self.state = 120
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 110
                self.prim_pattern()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 111
                self.prim_pattern()
                self.state = 112
                self.match(GrammarParser.OP_STAR)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 114
                self.prim_pattern()
                self.state = 115
                self.match(GrammarParser.OP_PLUS)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 117
                self.prim_pattern()
                self.state = 118
                self.match(GrammarParser.OP_Q)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Prim_patternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(GrammarParser.IDENT, 0)

        def NT_NAME(self):
            return self.getToken(GrammarParser.NT_NAME, 0)

        def LBR(self):
            return self.getToken(GrammarParser.LBR, 0)

        def pattern(self):
            return self.getTypedRuleContext(GrammarParser.PatternContext,0)


        def RBR(self):
            return self.getToken(GrammarParser.RBR, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_prim_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrim_pattern" ):
                listener.enterPrim_pattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrim_pattern" ):
                listener.exitPrim_pattern(self)




    def prim_pattern(self):

        localctx = GrammarParser.Prim_patternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_prim_pattern)
        try:
            self.state = 128
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.IDENT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 122
                self.match(GrammarParser.IDENT)
                pass
            elif token in [GrammarParser.NT_NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 123
                self.match(GrammarParser.NT_NAME)
                pass
            elif token in [GrammarParser.LBR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 124
                self.match(GrammarParser.LBR)
                self.state = 125
                self.pattern()
                self.state = 126
                self.match(GrammarParser.RBR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





